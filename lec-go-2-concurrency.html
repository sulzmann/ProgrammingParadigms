<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Martin Sulzmann" />
  <title>Google Go (golang) Part 2: Concurrency</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Google Go (golang) Part 2: Concurrency</h1>
  <p class="author">
Martin Sulzmann
  </p>
</div>
<div id="concurrency-in-google-go-golang" class="slide section level1">
<h1>Concurrency in Google Go (golang)</h1>
<ul>
<li><p>Light-weight threads</p></li>
<li><p>Channel-based communication</p></li>
<li><p>Non-deterministic selection</p>
<ul>
<li>Formal foundations: Communicating Sequential Processes, Sir Tony Hoare</li>
</ul></li>
<li><p>Philosophy: “Do not communicate by sharing memory. Instead share by communicating.”</p></li>
</ul>
<h2 id="concurrency-versus-parallelism">Concurrency versus Parallelism</h2>
<ul>
<li><p>Parallelism: Make programs run faster by making use of additional CPUs (parallel hardware)</p></li>
<li><p>Concurrency: Program organized into multiple threads of control. Threads may work independently or work on a common task.</p></li>
<li><p>See also here <a href="https://wiki.haskell.org/Parallelism_vs._Concurrency" class="uri">https://wiki.haskell.org/Parallelism_vs._Concurrency</a></p></li>
</ul>
</div>
<div id="concurrency-goroutine" class="slide section level1">
<h1>Concurrency (goroutine)</h1>
<p>Concurrent execution: &quot;just say go&quot;</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">func</span> thread(s <span class="dt">string</span>) {
    <span class="kw">for</span> {
        fmt.Print(s)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
    }
}

<span class="kw">func</span> main() {

    <span class="kw">go</span> thread(<span class="st">&quot;A&quot;</span>)
    <span class="kw">go</span> thread(<span class="st">&quot;B&quot;</span>)
    thread(<span class="st">&quot;C&quot;</span>)
}</code></pre></div>
<p>In Go we find cooperative multi-threading. That is, a thread will be executed until we reach a blocking statement (such as 'Sleep', receive on an empty channel, ...).</p>
<p>Let's consider a sample execution of the above example.</p>
<p>Each thread is in one of the following states:</p>
<pre><code>* Running
* Waiting
* Blocked</code></pre>
<pre><code>    Main.Running

--&gt; (Main.Running, A.Waiting)

--&gt; (Main.Running, A.Waiting, B.Waiting)

--&gt; (Main.Blocked, A.Waiting, B.Waiting)
</code></pre>
<ul>
<li><p>Main Thread is blocked due to Sleep</p></li>
<li><p>We pass control to one of the waiting threads</p></li>
<li><p>Generally, waiting threads are managed by a queue (FIFO)</p></li>
</ul>
<pre><code>
...

--&gt; (Main.Blocked, A.Waiting, B.Waiting)

--&gt; (Main.Blocked, A.Running, B.Waiting)

--&gt; (Main.Waiting, A.Blocked, B. Waiting)</code></pre>
<ul>
<li><p>The A thread blocks due to Sleep</p></li>
<li><p>Meanwhile, the Main thread switches from Blocked to Waiting (assuming that more than 1 second has passed)</p></li>
</ul>
<pre><code>
...

--&gt; (Main.Waiting, A.Blocked, B. Waiting)

--&gt; (Main.Waiting, A.Blocked, B.Running)</code></pre>
<p>and so on ...</p>
</div>
<div id="concurrency-issues" class="slide section level1">
<h1>Concurrency Issues</h1>
<p>Concurrent programming is a tricky business. Consider the following example.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> position <span class="kw">struct</span> {
    x <span class="dt">int</span>
    y <span class="dt">int</span>
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> p position

    <span class="co">// Producer 1</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        p.x = <span class="dv">1</span>
        p.y = <span class="dv">2</span>
    }()

    <span class="co">// Producer 2</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        p.x = <span class="dv">2</span>
        p.y = <span class="dv">3</span>
    }()

    <span class="co">// Consumer</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        x1 := p.x
        y1 := p.y
    }()

}</code></pre></div>
<p>A consumer threads waits for x-y coordinates supplied by either producer 1 or producer 2 thread.</p>
<p>There are several issues:</p>
<ul>
<li><p>Synchronization is via a <code>sleep</code> statement. There is no guarantee that once the consumer thread wakes up any of the producers has supplied the expected data.</p></li>
<li><p>Data races (data corruption) is possible. There is no guarantee that the x-y coordinates are written atomically.</p></li>
</ul>
<p>Next, we take a look at channel-based communication in Go for thread synchronization and data race free exchange of information.</p>
</div>
<div id="communication-channels" class="slide section level1">
<h1>Communication (&quot;channels&quot;)</h1>
<ul>
<li>Typed channels</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch <span class="kw">chan</span> <span class="dt">int</span></code></pre></div>
<ul>
<li>Channel declarations</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)      <span class="co">// No buffer</span>

ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">50</span>)  <span class="co">// Buffer size 50</span></code></pre></div>
<ul>
<li>Send</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch &lt;- y</code></pre></div>
<p>Send value <code>y</code> over channel <code>ch</code></p>
<ul>
<li>Receive</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x = &lt;- ch</code></pre></div>
<p>Receive from Kanal <code>ch</code>. Store received value in <code>x</code></p>
<ul>
<li>Example</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">func</span> snd(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> {
        x++
        ch &lt;- x
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
    }

}

<span class="kw">func</span> rcv(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span>
    <span class="kw">for</span> {
        x = &lt;-ch
        fmt.Printf(<span class="st">&quot;received %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)

    }

}

<span class="kw">func</span> main() {
    <span class="kw">var</span> ch <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> snd(ch)
    rcv(ch)

}</code></pre></div>
<ul>
<li>Uni-directional communication</li>
</ul>
<p>Sending only</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> snd(ch <span class="kw">chan</span> &lt;- <span class="dt">int</span>) { 
 ...
}</code></pre></div>
<p>Receiving only</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> rcv(ch &lt;- <span class="kw">chan</span> <span class="dt">int</span>) { 
 ...
}</code></pre></div>
<h2 id="sample-execution">Sample execution</h2>
<pre><code>    rcv.Running

--&gt; (rcv.Running, snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Running)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Blocked_(ch&lt;-1?))

--&gt; (rcv.Waiting, snd.Waiting)

--&gt; (rcv.Running, snd.Waiting)

...</code></pre>
<p>We consider the following variant.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> main() {
    <span class="kw">var</span> ch <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">1</span>) <span class="co">// Kanal mit Puffer</span>
    <span class="kw">go</span> snd(ch)
    rcv(ch)

}</code></pre></div>
<pre><code>    rcv.Running

--&gt; (rcv.Running, snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Running)

    // channel buffer full 

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Blocked_(Sleep(1s)?))

--&gt; (rcv.Waiting, snd.Blocked_(Sleep(1s)?))

    // channel buffer empty

--&gt; (rcv.Running, snd.Blocked_(Sleep(1s)?))

...</code></pre>
<p>As another variant. Channel with buffer size 1 and snd without Sleep.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> snd(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> {
        x++
        ch &lt;- x
    }

}</code></pre></div>
<pre><code>    rcv.Running

--&gt; (rcv.Running, snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Waiting)

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Running)

    // Channel buffer full

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Blocked_(ch&lt;-2?))

     // Two possibilies
     // (a) rcv reads from channel, or
     // (b) directly synchronizes with snd
     //
     // Go run-time follows case (a)

--&gt; (rcv.Running, snd.Blocked_(ch&lt;-2?))

     // Channel buffer empty

--&gt; (rcv.Blocked_(&lt;-ch?), snd.Blocked_(ch&lt;-2?))

     // Two possibilities
     // (a) snd writes into channel, or
     // (b) directly synchronizes with rcv
     //
     // Go run-time follows case (a)
</code></pre>
<p>Observations:</p>
<ul>
<li><p>In case of Sleep, execution becomes chaotic.</p></li>
<li><p>In case of a channel with buffer, send possibly is non-blocking (if enough buffer is available).</p></li>
<li><p>In case of a bufferless channel, the execution behavior is more predictable because each send must always synchronize with a receive.</p></li>
</ul>
<h2 id="extended-examples">Extended examples</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> snd(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> {
        x++
        ch &lt;- x
    }

}

<span class="kw">func</span> rcv(s <span class="dt">string</span>, ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span>
    <span class="kw">for</span> {
        x = &lt;-ch
        fmt.Printf(<span class="st">&quot;received %s %d </span><span class="ch">\n</span><span class="st">&quot;</span>, s, x)

    }

}

<span class="kw">func</span> main() {
    <span class="kw">var</span> ch <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> snd(ch)
    <span class="kw">go</span> rcv(<span class="st">&quot;A&quot;</span>, ch)
    rcv(<span class="st">&quot;B&quot;</span>, ch)

}</code></pre></div>
<p>Sample run (Macbook Air'15 OS 10.11)</p>
<pre><code>received A 2 
received A 3 
received A 4 
received A 5 
received A 6 
received A 7 
received A 8 
received A 9 
received A 10 
received B 1 
received A 11 
received A 12 
received B 13 
received B 15 
received B 16 
received B 17 
received B 18 
received B 19 
received B 20 
received B 21 
received B 22 
received B 23 
received B 24 
received B 25 
received B 26 
received B 27 
received B 28 
received B 29 
received B 30 
received B 31 
received B 32 
received B 33 
received B 34 
received B 35 
received B 36 
received B 37 
received B 38 
received B 39 
received B 40 
received B 41 
received B 42 
received B 43 
received B 44 
received B 45 
received B 46 
received B 47 
received B 48 
received B 49 
received B 50 
received B 51 
received B 52 
received B 53 
received B 54 
received B 55 
received B 56 
received B 57 
received B 58 
received B 59 
received B 60 
received B 61 
received B 62 
received B 63 
received B 64 
received B 65 
received B 66 
received B 67 
received A 14 
received B 68 
received B 70 
received B 71 
received B 72 
received B 73 
received B 74 
received B 75 
received B 76 
received B 77 
received B 78 
received A 69 
received B 79 
received A 80 
received B 81 
received B 83 
received B 84 
received B 85 
received B 86 
received B 87 
received B 88 </code></pre>
<p>FYI, on my old MacBook'08, only thread A is receiving.</p>
</div>
<div id="synchronous-versus-asynchronous-communication" class="slide section level1">
<h1>Synchronous versus asynchronous communication</h1>
<ul>
<li>Synchronous communication (the default case)
<ul>
<li>Sender blocks if there is no receive partner</li>
<li>Receiver blocks if there is no send partner</li>
</ul></li>
<li>Asynchronous communication via buffered channels
<ul>
<li>Sender blocks if buffer full</li>
<li>Receiver blocks if buffer empty</li>
</ul></li>
</ul>
<h2 id="exercise-mutex">Exercise: Mutex</h2>
<p>Go has support for standard synchronization primitives such as Mutex etc. See <a href="sync">http://golang.org/pkg/sync/</a>.</p>
<p>As an exercise, we implement our own Mutex via channels.</p>
<ul>
<li>Idea: Mutex represented as channel (one-place buffer)</li>
<li>Buffer initially empty</li>
<li><code>lock</code> equals send and <code>unlock</code> equals receive.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> Mutex (<span class="kw">chan</span> <span class="dt">int</span>)

<span class="kw">func</span> newMutex() Mutex {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">1</span>)
    <span class="kw">return</span> ch
}

<span class="kw">func</span> lock(m Mutex) {
    m &lt;- <span class="dv">1</span>
}

<span class="kw">func</span> unlock(m Mutex) {
    &lt;-m
}</code></pre></div>
<p>Variation:</p>
<ul>
<li><p>Represent the mutex as a synchronouns channel (no buffer)</p></li>
<li><p>Hint: Within <code>newMutex</code> create a &quot;receiving thread&quot;. Thus, some initial <code>lock</code> will not block.</p></li>
</ul>
</div>
<div id="indeterministic-choice-select" class="slide section level1">
<h1>Indeterministic choice (&quot;select&quot;)</h1>
<ul>
<li>Example
<ul>
<li>Receive on channel ch1</li>
<li>Receive on channel ch2</li>
<li>Send on channel ch3</li>
</ul></li>
<li>We wish to try each of the above events simultaneously
<ul>
<li>Event = Sending/receiving via some channel</li>
</ul></li>
<li><p>Some event may block whereas the other may execute successfully</p></li>
<li><p>In which order to try events?</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x = &lt;-ch1
y = &lt;-ch2
ch3 &lt;- <span class="dv">1</span></code></pre></div>
<p>versus</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">y = &lt;-ch2
x = &lt;-ch1
ch3 &lt;- <span class="dv">1</span></code></pre></div>
<p>Each event may block. How to try each event simultaneously?</p>
<ul>
<li>The <code>select</code> primitive allows us to simultanenously try several events</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">select</span> {
  <span class="kw">case</span> x = &lt;-ch1: ...
  <span class="kw">case</span> y = &lt;-ch2: ...
  <span class="kw">case</span> ch3 &lt;- <span class="dv">1</span>:
  <span class="co">// default and timeout possible</span>
}</code></pre></div>
<p>If one event, say <code>&lt;-ch1</code> is successful, then the respective case will be executed.</p>
<p>If there are several successful events, one event will be choosen indeterministically.</p>
<p>In theory, <code>select</code> can be encoded with just threads and channels. However, a faithful encoding is far from trivial.</p>
<p>In the following, we consider a bunch of examples to illustrate the workings and expressive power of <code>select</code>.</p>
<h2 id="example-receive-over-two-channels">Example: Receive over two channels</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>
<span class="kw">import</span> <span class="st">&quot;math/rand&quot;</span>

<span class="kw">func</span> snd(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> {
        x++
        ch &lt;- x
        <span class="kw">if</span> rand.Int()%<span class="dv">2</span> == <span class="dv">0</span> {
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        } <span class="kw">else</span> {
            time.Sleep(<span class="dv">5</span> * <span class="fl">1e9</span>)
        }
    }

}

<span class="kw">func</span> rcv(ch1 <span class="kw">chan</span> <span class="dt">int</span>, ch2 <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span>
    <span class="kw">for</span> {
        <span class="kw">select</span> {
        <span class="kw">case</span> x = &lt;-ch1:
            fmt.Printf(<span class="st">&quot;received ch1 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
        <span class="kw">case</span> x = &lt;-ch2:
            fmt.Printf(<span class="st">&quot;received ch2 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
        }

    }

}

<span class="kw">func</span> main() {
    <span class="kw">var</span> ch1 <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">var</span> ch2 <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> snd(ch1)
    <span class="kw">go</span> snd(ch2)
    rcv(ch1, ch2)

}</code></pre></div>
<h2 id="example-newsreader">Example: Newsreader</h2>
<p>Shows that an encoding of <code>select</code> with threads + channels is far from trivial.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">func</span> reuters(ch <span class="kw">chan</span> <span class="dt">string</span>) {
    ch &lt;- <span class="st">&quot;REUTERS&quot;</span>

}

<span class="kw">func</span> bloomberg(ch <span class="kw">chan</span> <span class="dt">string</span>) {
    ch &lt;- <span class="st">&quot;BLOOMBERG&quot;</span>

}

<span class="kw">func</span> newsReaderWithThreads(reutersCh <span class="kw">chan</span> <span class="dt">string</span>, bloombergCh <span class="kw">chan</span> <span class="dt">string</span>) {
    ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> <span class="kw">func</span>() {
        ch &lt;- (&lt;-reutersCh)
    }()

    <span class="kw">go</span> <span class="kw">func</span>() {
        ch &lt;- (&lt;-bloombergCh)
    }()

    x := &lt;-ch
    fmt.Printf(<span class="st">&quot;got news from %s </span><span class="ch">\n</span><span class="st">&quot;</span>, x)

}

<span class="kw">func</span> newsReaderWithSelect(reutersCh <span class="kw">chan</span> <span class="dt">string</span>, bloombergCh <span class="kw">chan</span> <span class="dt">string</span>) {
    <span class="kw">var</span> x <span class="dt">string</span>

    <span class="kw">select</span> {
    <span class="kw">case</span> x = &lt;-reutersCh:
    <span class="kw">case</span> x = &lt;-bloombergCh:
    }

    fmt.Printf(<span class="st">&quot;got news from %s </span><span class="ch">\n</span><span class="st">&quot;</span>, x)

}

<span class="kw">func</span> test1() {
    reutersCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)
    bloombergCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> reuters(reutersCh)
    <span class="kw">go</span> bloomberg(bloombergCh)
    newsReaderWithThreads(reutersCh, bloombergCh)
    newsReaderWithThreads(reutersCh, bloombergCh)
}

<span class="kw">func</span> test2() {
    reutersCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)
    bloombergCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> reuters(reutersCh)
    <span class="kw">go</span> bloomberg(bloombergCh)
    newsReaderWithSelect(reutersCh, bloombergCh)
    newsReaderWithSelect(reutersCh, bloombergCh)
}

<span class="kw">func</span> main() {
    test1() <span class="co">// potentially deadlocks</span>
    <span class="co">// test2()</span>
}</code></pre></div>
<ul>
<li><p>We attempt to encode <code>select</code> by spawning two helper threads. See <code>newsReaderWithThreads</code>.</p></li>
<li><p>Each helper treads waits for either a Reuters or Bloomberg message and redirects that messsage to a common channel.</p></li>
<li><p>The main thread waits on that common channel.</p></li>
<li><p>There is an issue if there are several newsreader and each newsreader attempts to consume either a Reuters or Bloomberg message.</p></li>
<li><p>Consider the following scenario:</p>
<ul>
<li><p>The first newreader consumes the Reuters message.</p></li>
<li><p>As the Bloomberg helper thread is still running, it's entirely possible that the Bloomberg message is retrieved without ever being consumed.</p></li>
<li><p>Hence, the second newsreader will block as there are no messages left!</p></li>
<li><p>Try running the above program. The go run-time will <code>fatal error: all goroutines are asleep - deadlock!</code></p></li>
</ul></li>
<li><p>In contrast, the <code>newsReaderWithSelect</code> version guarantees that each of the two newsreaders obtains either a Reuters or Bloomberg message.</p></li>
</ul>
<h2 id="example-execution-several-tasks">Example: Execution several tasks</h2>
<ul>
<li>Simultaneous execution several tasks</li>
<li>Continue if all taks are completed.</li>
<li>This program pattern is known as a <em>barrier</em>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">func</span> task1() { time.Sleep(<span class="dv">100</span> * time.Millisecond) }
<span class="kw">func</span> task2() { time.Sleep(<span class="dv">200</span> * time.Millisecond) }
<span class="kw">func</span> task3() { time.Sleep(<span class="dv">300</span> * time.Millisecond) }

<span class="kw">func</span> barrier() {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="co">// run all three tasks concurrently</span>
    <span class="kw">go</span> <span class="kw">func</span>() {
        task1()
        ch &lt;- <span class="dv">1</span> <span class="co">// signal done</span>
    }()
    <span class="kw">go</span> <span class="kw">func</span>() {
        task2()
        ch &lt;- <span class="dv">1</span>
    }()
    <span class="kw">go</span> <span class="kw">func</span>() {
        task3()
        ch &lt;- <span class="dv">1</span>
    }()

    <span class="co">// collect results concurrently</span>
    <span class="co">// set timeout to guarantee that within 500ms we&#39;re done</span>
    timeout := time.After(<span class="dv">500</span> * time.Millisecond)
    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++ {
        <span class="kw">select</span> {
        <span class="kw">case</span> &lt;-ch:
        <span class="kw">case</span> &lt;-timeout:
            fmt.Println(<span class="st">&quot;timed out&quot;</span>)
            <span class="kw">return</span>
        }

    }
    fmt.Println(<span class="st">&quot;done&quot;</span>)
}


<span class="kw">func</span> main() {
    barrier()
}</code></pre></div>
<h3 id="challenge">Challenge</h3>
<p>In the above, we guarantee that <em>all</em> tasks are completed within a certain time frame. In addition ensure that <em>each</em> tasks completes within a certain time frame.</p>
<p>Here's a possible attempt where we only show the relevant program parts.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    timeout := time.After(<span class="dv">500</span> * time.Millisecond)
    <span class="kw">for</span> i := <span class="dv">0</span>; i &lt; <span class="dv">3</span>; i++ {
        timeoutEach := time.After(<span class="dv">100</span> * time.Millisecond)
        <span class="kw">select</span> {
        <span class="kw">case</span> &lt;-ch:
        <span class="kw">case</span> &lt;-timeout:
            fmt.Println(<span class="st">&quot;timed out (global)&quot;</span>)
            <span class="kw">return</span>
        <span class="kw">case</span> &lt;-timeoutEach:
            fmt.Println(<span class="st">&quot;timed out (local)&quot;</span>)
            <span class="kw">return</span>
        }

    }
    fmt.Println(<span class="st">&quot;done&quot;</span>)</code></pre></div>
<p>We introduce a local timeout to keep track of the time spent each round. Notice that <code>timeoutEach</code> will be reset each time we enter the for-loop body.</p>
<p>Will this work?</p>
<p>No. It does not work. We only guarantee that the first task completes within the given time frame. In subsequent rounds we restart <code>timeoutEach</code> but some of the tasks are already running. Hence, there is no guarantee that all tasks respect the time frame imposed on each task.</p>
<p>What we require is to monitor each task with its own 'timeout' bound. We need something like this.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> completeWithin(task <span class="kw">func</span>(), ms time.Duration) <span class="kw">chan</span> <span class="dt">bool</span> {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">var</span> res = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">bool</span>)
    <span class="kw">go</span> <span class="kw">func</span>() {
        task()
        ch &lt;- <span class="dv">1</span>
    }()
    t := time.After(ms * time.Millisecond)
    <span class="kw">go</span> <span class="kw">func</span>() {
        <span class="kw">select</span> {
        <span class="kw">case</span> &lt;-ch:
            res &lt;- <span class="ot">true</span>
        <span class="kw">case</span> &lt;-t:
            res &lt;- <span class="ot">false</span>
        }
    }()
    <span class="kw">return</span> res
}</code></pre></div>
<p>As we may want to perform this check for several tasks, the function shall be non-blocking. Hence, the result, either true = task completed within time frame, or false = task took longer is communicated via a channel. The channel can then be queried later.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="co">// run all three tasks concurrently</span>
    <span class="co">// must complete within 500ms</span>
    r1 := completeWithin(task1, <span class="dv">500</span>)
    r2 := completeWithin(task2, <span class="dv">500</span>)
    r3 := completeWithin(task3, <span class="dv">500</span>)

    b1 := &lt;-r1
    b2 := &lt;-r2
    b3 := &lt;-r3

    <span class="kw">if</span> b1 &amp;&amp; b2 &amp;&amp; b3 {
        fmt.Println(<span class="st">&quot;done&quot;</span>)
    } <span class="kw">else</span> {
        fmt.Println(<span class="st">&quot;timed out&quot;</span>)
    }</code></pre></div>
</div>
<div id="deadlock" class="slide section level1">
<h1>Deadlock</h1>
<p>The go run-time is able to detect if all goroutines are asleep (i.e. are mutually blocked).</p>
<p>We say the program has a deadlock. A deadlock may not necessarily arise for all program runs. For example, consider</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
<span class="kw">go</span> <span class="kw">func</span>() {     <span class="co">// T1</span>
     &lt;- ch
     }()
<span class="kw">go</span> <span class="kw">func</span>() {     <span class="co">// T2</span>
     ch &lt;- <span class="dv">1</span>
     }()     
     
ch &lt;- <span class="dv">1</span></code></pre></div>
<p>It's possible that thread T1 synchronizes with thread T2 and therefore we run into a deadlock. However, it is also possible that the main thread synchronizes with thread T1 (and no deadlock occurs).</p>
<p>Here's an example for which we encounter a deadlock for all possible program runs.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
ch &lt;- <span class="dv">1</span></code></pre></div>
<h2 id="sample-runs">Sample runs</h2>
<p>Here's a sample run for which the program runs through.</p>
<pre><code>   (main.Running)
   -&gt; (main.Running, T1.Waiting)
   -&gt; (main.Running, T1.Waiting, T2.Waiting)
   -&gt; (main.Blocked_(ch&lt;-1?), T1.Waiting, T2.Waiting)
   -&gt; (main.Blocked_(ch&lt;-1?), T1.Running, T2.Waiting)
   -&gt; (main.Blocked_(ch&lt;-1?), T1.Blocked_(&lt;-ch?), T2.Waiting)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^
                     synchronize

   -&gt; (main.Waiting, T1.Waiting, T2.Waiting)
   -&gt; (main.Running, T1.Waiting, T2.Waiting)
   -&gt; main terminates all other thread terminate as well</code></pre>
<p>Here's another run where we encounter a deadlock.</p>
<pre><code>   (main.Running)
   -&gt; (main.Running, T1.Running)
   -&gt; (main.Running, T1.Running, T2.Waiting)
   -&gt; (main.Running, T1.Running, T2.Running)
   -&gt; (main.Blocked_(ch&lt;-1?), T1.Blocked_(&lt;-ch?), T2.Blocked_(ch&lt;-1?))

            either main synchronizes with T1, or
            T1 synchronizes with T2 (we choose the latter option here)

   -&gt; (main.Blocked_(ch&lt;-1?), T1.Waiting, T2.Waiting)
   -&gt; (main.Blocked_(ch&lt;-1?), T1.Running, T2.Running)
   -&gt; (main.Blocked_(ch&lt;-1?))

     T1 and T2 terminate, main thread is still blocked! Hence, deadlock!</code></pre>
<h2 id="newsreader-variant">Newsreader variant</h2>
<p>We know that the newsreader with thread variants (possibly) runs into a deadlock. On my Mac it seems that all runs result into a deadlock. To highlight that not all runs result into a deadlock, we include a sleep statement for one of the worker threads.</p>
<p>Run the below, in contrast to the earlier variant, no deadlock will (most likely) be observed.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">
<span class="kw">func</span> newsReaderWithThreads(reutersCh <span class="kw">chan</span> <span class="dt">string</span>, bloombergCh <span class="kw">chan</span> <span class="dt">string</span>) {
    ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> <span class="kw">func</span>() {
        ch &lt;- (&lt;-reutersCh)
    }()

    <span class="kw">go</span> <span class="kw">func</span>() {
        ch &lt;- (&lt;-bloombergCh)
    }()

    x := &lt;-ch
    fmt.Printf(<span class="st">&quot;got news from %s </span><span class="ch">\n</span><span class="st">&quot;</span>, x)

}


<span class="kw">func</span> newsReaderWithThreadsAndSleep(reutersCh <span class="kw">chan</span> <span class="dt">string</span>, bloombergCh <span class="kw">chan</span> <span class="dt">string</span>) {
    ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> <span class="kw">func</span>() {
        ch &lt;- (&lt;-reutersCh)
    }()

    <span class="kw">go</span> <span class="kw">func</span>() {
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)     
        ch &lt;- (&lt;-bloombergCh)
    }()

    x := &lt;-ch
    fmt.Printf(<span class="st">&quot;got news from %s </span><span class="ch">\n</span><span class="st">&quot;</span>, x)

}


<span class="kw">func</span> main() {
    reutersCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)
    bloombergCh := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)

    <span class="kw">go</span> reuters(reutersCh)
    <span class="kw">go</span> bloomberg(bloombergCh)
    newsReaderWithThreadsAndSleep(reutersCh, bloombergCh)
    newsReaderWithThreads(reutersCh, bloombergCh)
}</code></pre></div>
</div>
<div id="channels-of-channels" class="slide section level1">
<h1>Channels of channels</h1>
<p>Channels are first-class citizens.</p>
<p>Channels can be arguments of channels.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="st">`var ch chan (chan int)`</span></code></pre></div>
<p>A channel where the transmitted values are themselves channels.</p>
<p>Thus, we can encode complex synchronization patterns.</p>
<h2 id="example">Example</h2>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">type</span> Request <span class="kw">struct</span> {
    id  <span class="dt">int</span>
    ack <span class="kw">chan</span> <span class="dt">int</span>
}</code></pre></div>
<p>A request consists of an identification number and a channel. The channel is used to acknowledge a successful request.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> worker(req <span class="kw">chan</span> Request) {
    <span class="kw">var</span> c Request
    <span class="kw">for</span> {
        c = &lt;-req
        fmt.Printf(<span class="st">&quot;request received from %d </span><span class="ch">\n</span><span class="st">&quot;</span>, c.id)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        fmt.Println(<span class="st">&quot;notify&quot;</span>)
        c.ack &lt;- <span class="dv">1</span>
    }
}</code></pre></div>
<p>Wait for requests. Acknowledge reception of request via channel <code>ack</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> client(id <span class="dt">int</span>, req <span class="kw">chan</span> Request) {
    <span class="kw">var</span> ack = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">for</span> {
        c := Request{id, ack}
        req &lt;- c
        &lt;-ack
    }

}</code></pre></div>
<p>Transmit request and wait for acknowledgment by performing a receive on channel <code>ack</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> main() {
    <span class="kw">var</span> req = <span class="fu">make</span>(<span class="kw">chan</span> Request)
    <span class="kw">go</span> worker(req)
    <span class="kw">go</span> client(<span class="dv">1</span>, req)
    client(<span class="dv">2</span>, req)
}</code></pre></div>
<h2 id="sleeping-barber">Sleeping barber</h2>
<p>A classic synchronization problem.</p>
<p>In its most simple form, the sleeping barber problem can be described as follows:</p>
<ul>
<li>A barber cuts hair, at most one customer at a time</li>
<li>Customers must wait until the barber is available</li>
</ul>
<p>Here is a direct implementation.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">const</span> (
    NUMBER_OF_CHAIRS = <span class="dv">8</span>
)

<span class="kw">type</span> Request <span class="kw">struct</span> {
    id  <span class="dt">int</span>
    ack <span class="kw">chan</span> <span class="dt">int</span>
}

<span class="kw">func</span> barber(waitQ (<span class="kw">chan</span> Request)) {

    <span class="kw">for</span> {
        req := &lt;-waitQ
        fmt.Printf(<span class="st">&quot;BARBER: Serving customer %d </span><span class="ch">\n</span><span class="st">&quot;</span>, req.id)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        fmt.Printf(<span class="st">&quot;BARBER: Done with customer %d </span><span class="ch">\n</span><span class="st">&quot;</span>, req.id)
        req.ack &lt;- <span class="dv">1</span>

    } <span class="co">// for</span>

} <span class="co">// barber</span>

<span class="kw">func</span> customer(waitQ (<span class="kw">chan</span> Request), id <span class="dt">int</span>) {
    <span class="kw">var</span> ack = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">for</span> {

        fmt.Printf(<span class="st">&quot;CUSTOMER: %d wants hair cut </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        req := Request{id, ack}
        waitQ &lt;- req
        fmt.Printf(<span class="st">&quot;CUSTOMER: %d sits on chair </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        &lt;-ack
        fmt.Printf(<span class="st">&quot;CUSTOMER: %d served by barber </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)

    } <span class="co">// for</span>

} <span class="co">// customer</span>

<span class="kw">func</span> main() {

    <span class="kw">var</span> (
        waitQ = <span class="fu">make</span>(<span class="kw">chan</span> Request, NUMBER_OF_CHAIRS)
    )

    <span class="kw">go</span> customer(waitQ, <span class="dv">1</span>)
    <span class="kw">go</span> customer(waitQ, <span class="dv">2</span>)
    barber(waitQ)

}</code></pre></div>
</div>
<div id="summary" class="slide section level1">
<h1>Summary</h1>
<ul>
<li>Focus on concurrency
<ul>
<li>Light-weight threads</li>
<li>Channel-based communication</li>
<li>Non-deterministic selection</li>
</ul></li>
</ul>
<h2 id="highlights">Highlights</h2>
<h3 id="synchronous-channels">Synchronous channels</h3>
<p>The following declaration introduces a <em>synchronous</em> channel.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)</code></pre></div>
<p>Each sender blocks until a receiver arrives. For example, consider concurrent execution of<br />
the following program fragments.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch &lt;- <span class="dv">1</span>   </code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x := &lt;- ch   </code></pre></div>
<h3 id="asynchronous-channels">Asynchronous channels</h3>
<p>The following declaration introduces a <em>asynchronous</em> channel.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">2</span>)</code></pre></div>
<p>The buffer size of the (asynchronous) channel is 2. As long as there is sufficient space in the buffer, a sender won't block (that is, act asynchronously).</p>
<p>For example, consider the concurrent execution of the following program fragments.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch &lt;- <span class="dv">1</span>   
ch &lt;- <span class="dv">2</span>
ch &lt;- <span class="dv">3</span>  <span class="co">// S</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x := &lt;- ch   <span class="co">// R</span></code></pre></div>
<p>The sender will block at program point <code>S</code> until at program point <code>R</code> we have received 1 (channels behave like queues according to the FIFO principle).</p>
<h3 id="deadlocks">Deadlocks</h3>
<p>Suppose we execute the following program fragments concurrently. Will we run into a deadlock?</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch1 &lt;- <span class="dv">1</span>  <span class="co">// S1</span>
ch2 &lt;- <span class="dv">1</span>  <span class="co">// S2</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">x := &lt;-ch2  <span class="co">// R2  </span>
y := &lt;-ch1  <span class="co">// R1</span></code></pre></div>
<p>Depends on the kind of channels. Suppose, we have</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch1 := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
ch2 := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)</code></pre></div>
<p>The above program will then deadlock because</p>
<ul>
<li><code>S1</code> can only be synchronized with <code>R1</code>, but</li>
<li><code>R1</code> is not reachable because the earlier program point <code>R2</code> first has to synchronize with <code>S2</code>.</li>
<li>However, <code>S2</code> is only reachable once <code>S1</code> can be synchronized.</li>
<li>We encounter a dependency cycle, i.e. deadlock.</li>
</ul>
<p>Suppose, we have</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">ch1 := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>,<span class="dv">1</span>)
ch2 := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)</code></pre></div>
<p>The first send at program point <code>S1</code> will not block and therefore the program runs through (without deadlock).</p>
<h3 id="non-deterministic-select">(Non-deterministic) select</h3>
<p>Suppose we want to implement a news reader, receiving information from various sources (Reuters, Bloomberg etc). In which order shall we receiver the news? Difficult to specify a fixed order. What if we first choose Reuters but for some reason Reuters has a temporary black-out. Well, then let's frist choose Bloomborg. Erh, same problem.</p>
<h4 id="first-attempt">First attempt</h4>
<p>Let's have two threads, collecting news from Reuters and Bloomberg. Each thread passes on the news to a common channel which will be read by our news reader.</p>
<p>The thread taken care of Reuters:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">for</span> {
  x:= &lt;-chReuters
  chNews &lt;- x
}</code></pre></div>
<p>The thread taking care of Bloomberg:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">for</span> {
  x:= &lt;-chBloomberg
  chNews &lt;- x
}</code></pre></div>
<p>Finally, our news reader:</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">for</span> {
  someNews := &lt;- chNews
}</code></pre></div>
<p>Issue:</p>
<ul>
<li>There's no fairness guarantee.</li>
<li>Likely that we favor one of the news channels</li>
<li>What if we are interested in a single message, either from Reuters or Bloomberg. Consider the following variant.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">chNews := <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">string</span>)
<span class="kw">go</span> <span class="kw">func</span>() {   x:= &lt;-chReuters
              chNews &lt;- x}()
<span class="kw">go</span> <span class="kw">func</span>() {   x:= &lt;-chBloomberg
              chNews &lt;- x}()          
someNews := &lt;- chNews</code></pre></div>
<p>So, there is a race among the two threads. As we are only interested in a single message, only one of the 'winning' thread will be able to transfer the message. The 'loosing' thread takes out the message from the news channel but as there is no receiver, this message will never be delivered and therefore is lost. For example, consider the situation that there are several clients only interested in a single message, either from Reuters and Bloomberg.</p>
<p>Hence, the 'loosing' thread would need to be informed to transfer back the unnecessarily consumed message. This requires a rather complicated protocol and also destroys the order in which messages are processed.</p>
<h3 id="second-attempt-via-non-deterministic-select">Second attempt via non-deterministic select</h3>
<p>Good news. GoLang supports the non-deterministic selection over multiple events (i.e. send/receive). We can simply say</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">select</span> {
  <span class="kw">case</span> x := &lt;-chReuters:   <span class="co">// R</span>
  <span class="kw">case</span> y := &lt;-chBloomberg: <span class="co">// B</span>
}</code></pre></div>
<ul>
<li><p><code>select</code> blocks if neither a value has been transmitted over chReuters nor chBloomberg.</p></li>
<li><p>If a value has been transmitted via chReuters, <code>select</code> will choose R.</p></li>
<li><p>If a value has been transmitted via chBloomberg, <code>select</code> will choose B.</p></li>
<li><p>What if a value has been transmitted via chReuters <em>and</em> chBloomberg?</p>
<ul>
<li><code>select</code> will non-deterministically choose among R or B.</li>
<li>The textual order of the <code>case</code> clauses does not matter.</li>
<li>Thus, <code>select</code> provides a fairness guarantee. This is useful in case there is high-traffic over say chReuters because we still will some times choose B.</li>
</ul></li>
</ul>
<h3 id="giving-preference">Giving preference</h3>
<p>What if we prefer to read Reuters? We can use a nested <code>select</code> statement with a <code>default</code> case.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">select</span> {
  <span class="kw">case</span> x := &lt;-chReuters:   <span class="co">// R</span>
  <span class="kw">case</span> y := &lt;-chBloomberg: <span class="kw">select</span> {
                              <span class="kw">case</span> x&#39; := &lt;chReuters:  <span class="co">// prefer Reuters</span>
                              <span class="kw">default</span>:                <span class="co">// Bloomberg if no Reuters news</span>
                           }
}</code></pre></div>
<ul>
<li>The <code>default</code> case will only be choosen if all cases will block</li>
</ul>
</div>
<div id="exercises" class="slide section level1">
<h1>Exercises</h1>
<ul>
<li><p>Concurrency basics: Threading and channels in GoLang</p></li>
<li>Mutex, Semaphores
<ul>
<li>Encoding some standard synchronization primitives with channels</li>
<li>The encodings are fairly straightforward if we are allowed to use buffered channels but become fairly tricky if using only synchronous channels</li>
<li>Specifically, we consider an encoding of a mutable variable with synchronous channels</li>
</ul></li>
<li>Sleeping barber
<ul>
<li>A classic synchronization exercises where we make use of &quot;channels of channels&quot;</li>
</ul></li>
</ul>
</div>
<div id="concurrency---basics" class="slide section level1">
<h1>Concurrency - Basics</h1>
<ul>
<li>Recall the following program from class. The following features are covered:
<ul>
<li>Channel-based communication</li>
<li>Selective wait by (indeterministically) querying two channels</li>
</ul></li>
<li>Play around with the example
<ul>
<li>Change the sleep timing</li>
<li>Introduce further send/receive threads</li>
<li>Introduce buffered channels</li>
</ul></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>
<span class="kw">import</span> <span class="st">&quot;math/rand&quot;</span>

<span class="kw">func</span> snd(ch <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">0</span>
    <span class="kw">for</span> {
        x++
        ch &lt;- x
        <span class="kw">if</span> rand.Int()%<span class="dv">2</span> == <span class="dv">0</span> {
            time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        } <span class="kw">else</span> {
            time.Sleep(<span class="dv">5</span> * <span class="fl">1e9</span>)
        }
    }

}

<span class="kw">func</span> rcv(ch1 <span class="kw">chan</span> <span class="dt">int</span>, ch2 <span class="kw">chan</span> <span class="dt">int</span>) {
    <span class="kw">var</span> x <span class="dt">int</span>
    <span class="kw">for</span> {
        <span class="kw">select</span> {
        <span class="kw">case</span> x = &lt;-ch1:
            fmt.Printf(<span class="st">&quot;received ch1 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
        <span class="kw">case</span> x = &lt;-ch2:
            fmt.Printf(<span class="st">&quot;received ch2 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
        }

    }

}

<span class="kw">func</span> main() {
    <span class="kw">var</span> ch1 <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">var</span> ch2 <span class="kw">chan</span> <span class="dt">int</span> = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> snd(ch1)
    <span class="kw">go</span> snd(ch2)
    rcv(ch1, ch2)

}</code></pre></div>
</div>
<div id="concurrency---mutex-semaphores" class="slide section level1">
<h1>Concurrency - Mutex, Semaphores</h1>
<ul>
<li>Recall from class how to model a mutex using Go's channel
<ul>
<li>Write a program which contains a deadlock</li>
<li>Observe the reaction by the Google Go run-time system</li>
</ul></li>
<li><p>How to model/implement a Semaphore?</p></li>
<li><p>Your Semaphore implementation probably relies on a buffered channel. Could you implement a Semaphore with a synchronous channel only?</p></li>
</ul>
<h2 id="comments-and-further-questions">Comments and further questions</h2>
<h3 id="mutex">Mutex</h3>
<p>Sample solution mutex</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>

<span class="kw">type</span> Mutex (<span class="kw">chan</span> <span class="dt">int</span>)

<span class="kw">func</span> newMutex() Mutex {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>, <span class="dv">1</span>)
    <span class="kw">return</span> ch
}

<span class="kw">func</span> lock(m Mutex) {
    m &lt;- <span class="dv">1</span>
}

<span class="kw">func</span> unlock(m Mutex) {
    &lt;-m
}

<span class="kw">func</span> main() {
    <span class="kw">var</span> m Mutex

    m = newMutex()

    lock(m)
    fmt.Print(<span class="st">&quot;locked</span><span class="ch">\n</span><span class="st">&quot;</span>)
    unlock(m)

    fmt.Print(<span class="st">&quot;done</span><span class="ch">\n</span><span class="st">&quot;</span>)

}</code></pre></div>
<p>Write a program which will deadlock</p>
<h3 id="semaphoremvar">Semaphore/MVar</h3>
<p>We can almost trivially model/implement semaphores via buffered channel.</p>
<p>Can we implement semaphores with just synchronous (bufferless) channels? Yes!</p>
<p>For simplicity, we consider a mutuable variable which roughly corresponds to a semaphore with quantity one. The MVar interface shall be as follows.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">type</span> MVar (<span class="kw">chan</span> <span class="dt">int</span>)
<span class="kw">func</span> newMVar(x <span class="dt">int</span>) MVar
<span class="kw">func</span> takeMVar(m MVar) <span class="dt">int</span>
<span class="kw">func</span> putMVar(m MVar, x <span class="dt">int</span>)</code></pre></div>
<ul>
<li>An MVar is either full or empty</li>
<li>Initially, an MVar holds an integer value</li>
<li><code>takeMVar</code>
<ul>
<li>reads out (<em>takes</em>) the value if full</li>
<li>blocks otherwise</li>
</ul></li>
<li><code>putMVar</code>
<ul>
<li>writes (<em>puts</em>) a value if empty</li>
<li>blocks otherwise</li>
</ul></li>
<li>Note
<ul>
<li><code>takeMVar</code> corresonds to receive</li>
<li><code>putMVar</code> corresponds to send</li>
<li>We can trivially implement an MVar via a buffered channel (1-element buffer)</li>
</ul></li>
</ul>
<p>Let's try to implement an MVar via a synchronous (bufferless) channel. Our first try has a bug which will be fixed later.</p>
<h4 id="first-try-failed-attempt">First try (failed attempt)</h4>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">type</span> MVar (<span class="kw">chan</span> <span class="dt">int</span>)

<span class="kw">func</span> newMVar(x <span class="dt">int</span>) MVar {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> <span class="kw">func</span>() { ch &lt;- x }()
    <span class="kw">return</span> ch
}</code></pre></div>
<p>Trick:</p>
<ul>
<li>Fill MVar (channel) in a concurrent thread.</li>
<li>This thread may block, but <code>newMVar</code> won't block and returns the MVar</li>
</ul>
<p>Remaining operations are then trivial.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> takeMVar(m MVar) <span class="dt">int</span> {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = &lt;-m
    <span class="kw">return</span> x
}

<span class="kw">func</span> putMVar(m MVar, x <span class="dt">int</span>) {
    m &lt;- x
}</code></pre></div>
<p>But <em>there's problem</em>.</p>
<p>The above won't work in case of subsequent takes and puts in the <em>same</em> thread.</p>
<p>Consider</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go">    <span class="kw">var</span> m MVar
    m = newMVar(<span class="dv">1</span>)   <span class="co">// Full</span>
    takeMVar(m)      <span class="co">// Empty</span>
    putMVar(m, <span class="dv">2</span>)    <span class="co">// Full</span></code></pre></div>
<p>The above program text is annotated with the <em>desired</em> MVar state (full or empty). Recall that the initial filling of the MVar happens in a concurrent thread. Hence, the call <code>newMVar(1)</code> won't block.</p>
<p>The actual problem is that <code>takeMVar</code> and <code>putMvar</code> are built upon synchronous send/receive operations. Recall that we use here a channel without buffer!</p>
<p>So what could we do to fix the problem?</p>
<h4 id="concurrent-thread-to-control-mvar-state">Concurrent thread to control MVar state</h4>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">const</span> (
    Empty = <span class="dv">0</span>
    Full  = <span class="dv">1</span>
)

<span class="kw">func</span> newMVar(x <span class="dt">int</span>) MVar {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> <span class="kw">func</span>() {
        <span class="kw">var</span> state = Full
        <span class="kw">var</span> elem <span class="dt">int</span> = x
        <span class="kw">for</span> {
            <span class="kw">switch</span> {
            <span class="kw">case</span> state == Full:
                ch &lt;- elem     <span class="co">// FULL</span>
                state = Empty
            <span class="kw">case</span> state == Empty:
                elem = &lt;-ch    <span class="co">// EMPTY</span>
                state = Full
            }
        }
    }()
    <span class="kw">return</span> ch
}</code></pre></div>
<p>Each <code>newMVar</code> call starts an &quot;asynchronous&quot; worker thread which controls the MVar state and helps to unblock <code>takeMVar</code> and <code>putMVar</code> calls.</p>
<p>No changes are required to <code>takeMVar</code> and <code>putMVar</code>.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">func</span> takeMVar(m MVar) <span class="dt">int</span> {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = &lt;-m      <span class="co">// TAKE</span>
    <span class="kw">return</span> x
}

<span class="kw">func</span> putMVar(m MVar, x <span class="dt">int</span>) {
    m &lt;- x      <span class="co">// PUT</span>
}</code></pre></div>
<p>Let's consider a few use cases. We will refer to the (above) annotated program positions FULL, EMPTY, TAKE, PUT.</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"> m := newMVar(<span class="dv">1</span>)
 x := takeMVar(m)
 putMVar(m, x<span class="dv">+1</span>)</code></pre></div>
<ol style="list-style-type: decimal">
<li>The worker thread created by the <code>newMVar</code> call blocks at position FULL. Our main thread of course continues.</li>
<li>The <code>takeMVar</code> calls reaches position TAKE and can synchronize with the concurrent worker thread.</li>
<li>Both threads (main and worker) continue.</li>
<li>The worker thread will block at position EMPTY.</li>
<li>The main thread executes the <code>putMVar</code> call. Position PUT will synchronize with position EMPTY.</li>
</ol>
<p>Here's another example which involves three user threads (recall there's a fourth worker thread created by <code>newMVar</code>).</p>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"> m := newMVar(<span class="dv">1</span>)                     <span class="co">// P1</span>
    <span class="co">// THREAD 1</span>
 <span class="kw">go</span> <span class="kw">func</span>() { x := takeMVar(m)        <span class="co">// P2</span>
             y := takeMVar(m)        <span class="co">// P3</span>
           }()
    <span class="co">// THREAD 2</span>
 <span class="kw">go</span> <span class="kw">func</span>() { putMVar(m,<span class="dv">2</span>)            <span class="co">// P4</span>
           }()</code></pre></div>
<p>A possible execution schedule is as follows.</p>
<ol style="list-style-type: decimal">
<li>In THREAD 1, the first <code>takeMVar</code>, at position P2, synchronizes with the worker thread, at position FULL, and therefore assigns 1 to x. Then, the thread blocks when executing the second <code>takeMVar</code> call, at position P3.</li>
<li>The <code>putMVar</code> call, at position P4, synchronizes with the worker thread, at position EMPTY.</li>
<li>Subsequently, the <code>takeMVar</code> call at postion P3 unblocks and we assign 2 to y.</li>
</ol>
<p>In theory, another execution schedule is possible.</p>
<ol style="list-style-type: decimal">
<li>The Worker thread blocks at position FULL.</li>
<li>THREAD 1 blocks at postion P2 (position TAKE within <code>takeMVar</code>)</li>
<li>THREAD 2 blocks at position P4 (position PUT within <code>putMVar</code>)</li>
<li>We have two blocked &quot;writers&quot; (worker thread and THREAD 2) and one blocked &quot;reader&quot; (THREAD 1)</li>
<li>Let's assume that THREAD 1 and THREAD 2 synchronize with each other.</li>
<li>Then, 2 is assigned to x and THREAD 1 advances to block again at position P3.</li>
<li>Next, the worker thread and THREAD 1 synchronize with each other.</li>
<li>Then, 1 is assigned to y.</li>
</ol>
<p>The conclusion is that a <code>newMVar</code> can be &quot;overtaken&quot; by a subsequent <code>putMVar</code> executed in some concurrent thread. A <code>takeMVar</code> can pick up the value from <code>putMVar</code> instead of <code>newMVar</code>. This may seem a little strange first but there's really nothing wrong here. (In practice, it'll be quite tricky to create this specific situation).</p>
<p>Our revised MVar implementation is correct and simply follows a slightly more general semantics where the initial &quot;write&quot; by <code>newMVar</code> might not necessarily be picked up the the &quot;first&quot; <code>takeMVar</code>. We can argue that in a concurrent world such a thing as &quot;first&quot; is difficult to test, to observe and to guarantee.</p>
<p>Also note that two concurrent <code>takeMvar</code> and <code>putVar</code> calls may react with each other without changing the MVar state. That is, without interacting with the worker thread.</p>
<h4 id="complete-mvar-solution">Complete MVar solution</h4>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">type</span> MVar (<span class="kw">chan</span> <span class="dt">int</span>)

<span class="kw">const</span> (
    Empty = <span class="dv">0</span>
    Full  = <span class="dv">1</span>
)

<span class="kw">func</span> newMVar(x <span class="dt">int</span>) MVar {
    <span class="kw">var</span> ch = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">go</span> <span class="kw">func</span>() {
        <span class="kw">var</span> state = Full
        <span class="kw">var</span> elem <span class="dt">int</span> = x
        <span class="kw">for</span> {
            <span class="kw">switch</span> {
            <span class="kw">case</span> state == Full:
                ch &lt;- elem
                state = Empty
            <span class="kw">case</span> state == Empty:
                elem = &lt;-ch
                state = Full
            }
        }
    }()
    <span class="kw">return</span> ch
}

<span class="kw">func</span> takeMVar(m MVar) <span class="dt">int</span> {
    <span class="kw">var</span> x <span class="dt">int</span>
    x = &lt;-m
    <span class="kw">return</span> x
}

<span class="kw">func</span> putMVar(m MVar, x <span class="dt">int</span>) {
    m &lt;- x
}

<span class="kw">func</span> producer(m MVar) {
    <span class="kw">var</span> x <span class="dt">int</span> = <span class="dv">1</span>
    <span class="kw">for</span> {
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        putMVar(m, x)
        x++
    }
}

<span class="kw">func</span> consumer(m MVar) {
    <span class="kw">for</span> {
        <span class="kw">var</span> x <span class="dt">int</span> = takeMVar(m)
        fmt.Printf(<span class="st">&quot;Received %d </span><span class="ch">\n</span><span class="st">&quot;</span>, x)
    }
}

<span class="kw">func</span> main() {

    test1()

} <span class="co">// main</span>

<span class="kw">func</span> test1() {
    <span class="kw">var</span> m MVar
    m = newMVar(<span class="dv">1</span>)
    takeMVar(m)
    putMVar(m, <span class="dv">2</span>)
    fmt.Print(<span class="st">&quot;won&#39;t get here&quot;</span>)

}

<span class="kw">func</span> test2() {
    <span class="kw">var</span> m MVar
    m = newMVar(<span class="dv">1</span>)
    <span class="kw">go</span> producer(m)
    consumer(m)
}

<span class="co">// almost impossible to create a situation</span>
<span class="co">// where a subsequent putMVar overtakes the initial &#39;put&#39; of newMVar</span>
<span class="kw">func</span> test() {
    <span class="kw">var</span> m MVar
    m = newMVar(<span class="dv">1</span>)
    <span class="kw">go</span> fmt.Printf(<span class="st">&quot;Take1 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, takeMVar(m))
    <span class="kw">go</span> putMVar(m, <span class="dv">2</span>)
    fmt.Printf(<span class="st">&quot;Take2 %d </span><span class="ch">\n</span><span class="st">&quot;</span>, takeMVar(m))
    time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)

}</code></pre></div>
</div>
<div id="concurrency---sleeping-barber" class="slide section level1">
<h1>Concurrency - Sleeping barber</h1>
<p>Consider a barber shop where there is only one barber. When there are no customers the barber sleeps. When a customer arrives he awakes and cuts the customer's hair. In case of several customers arriving the barber chooses one randomly.</p>
<p>The following variations/extensions exist:</p>
<ul>
<li><p>There are n waiting chairs. If the barber is busy, the customer takes a seat. If there are no seats left, the customer leaves (and tries again after a certain amount of time)</p></li>
<li><p>There are several barbers serving customers</p></li>
</ul>
<p>Below is a sample solution for the first variant.</p>
<ul>
<li><p>Play around with the sample solution (change the number of customers, waiting chairs)</p></li>
<li><p>Attempt the second variant (several barbers)</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode go"><code class="sourceCode go"><span class="kw">package</span> main

<span class="kw">import</span> <span class="st">&quot;fmt&quot;</span>
<span class="kw">import</span> <span class="st">&quot;time&quot;</span>

<span class="kw">const</span> (
    NUMBER_OF_CHAIRS = <span class="dv">8</span>
)

<span class="kw">type</span> Request <span class="kw">struct</span> {
    id  <span class="dt">int</span>
    ack <span class="kw">chan</span> <span class="dt">int</span>
}

<span class="kw">func</span> barber(waitQ (<span class="kw">chan</span> Request)) {

    <span class="kw">for</span> {
        req := &lt;-waitQ
        fmt.Printf(<span class="st">&quot;BARBER: Serving customer %d </span><span class="ch">\n</span><span class="st">&quot;</span>, req.id)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)
        fmt.Printf(<span class="st">&quot;BARBER: Done with customer %d </span><span class="ch">\n</span><span class="st">&quot;</span>, req.id)
        req.ack &lt;- <span class="dv">1</span>

    } <span class="co">// for</span>

} <span class="co">// barber</span>

<span class="kw">func</span> customer(waitQ (<span class="kw">chan</span> Request), id <span class="dt">int</span>) {
    <span class="kw">var</span> ack = <span class="fu">make</span>(<span class="kw">chan</span> <span class="dt">int</span>)
    <span class="kw">for</span> {

        fmt.Printf(<span class="st">&quot;CUSTOMER: %d wants hair cut </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        req := Request{id, ack}
        waitQ &lt;- req
        fmt.Printf(<span class="st">&quot;CUSTOMER: %d sits on chair </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        &lt;-ack
        fmt.Printf(<span class="st">&quot;CUSTOMER: %d served by barber </span><span class="ch">\n</span><span class="st">&quot;</span>, id)
        time.Sleep(<span class="dv">1</span> * <span class="fl">1e9</span>)

    } <span class="co">// for</span>

} <span class="co">// customer</span>

<span class="kw">func</span> main() {

    <span class="kw">var</span> (
        waitQ = <span class="fu">make</span>(<span class="kw">chan</span> Request, NUMBER_OF_CHAIRS)
    )

    <span class="kw">go</span> customer(waitQ, <span class="dv">1</span>)
    <span class="kw">go</span> customer(waitQ, <span class="dv">2</span>)
    barber(waitQ)

}</code></pre></div>
</div>
</body>
</html>
